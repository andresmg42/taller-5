file://<WORKSPACE>/src/test/scala/pruebas.worksheet.sc
### file%3A%2F%2F%2Fhome%2Fandresuv%2FcuartoSemestre%2FPFC%2Fentregables%2Fmatrices%2Fsrc%2Ftest%2Fscala%2Fpruebas.worksheet.sc:559: error: Not one of: `$$', `$'ident, `$'this, `$'BlockExpr, `$'_
    case(((a,b,c),d))=> writer.println(s"d,$")
                                         ^

occurred in the presentation compiler.

presentation compiler configuration:
Scala version: 2.13.12
Classpath:
/modules [exists ], <WORKSPACE>/.bloop/root/bloop-bsp-clients-classes/test-classes-Metals-NH5TBhhvTDGtwExu5NsAWg== [exists ], <HOME>/.cache/bloop/semanticdb/com.sourcegraph.semanticdb-javac.0.9.9/semanticdb-javac-0.9.9.jar [exists ], <WORKSPACE>/.bloop/root/bloop-bsp-clients-classes/classes-Metals-NH5TBhhvTDGtwExu5NsAWg== [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.12/scala-library-2.13.12.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scalatest/scalatest_2.13/3.2.17/scalatest_2.13-3.2.17.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/com/storm-enroute/scalameter-core_2.13/0.21/scalameter-core_2.13-0.21.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/modules/scala-parallel-collections_2.13/1.0.3/scala-parallel-collections_2.13-1.0.3.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scalameta/munit_2.13/0.7.26/munit_2.13-0.7.26.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scalatest/scalatest-core_2.13/3.2.17/scalatest-core_2.13-3.2.17.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scalatest/scalatest-featurespec_2.13/3.2.17/scalatest-featurespec_2.13-3.2.17.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scalatest/scalatest-flatspec_2.13/3.2.17/scalatest-flatspec_2.13-3.2.17.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scalatest/scalatest-freespec_2.13/3.2.17/scalatest-freespec_2.13-3.2.17.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scalatest/scalatest-funsuite_2.13/3.2.17/scalatest-funsuite_2.13-3.2.17.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scalatest/scalatest-funspec_2.13/3.2.17/scalatest-funspec_2.13-3.2.17.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scalatest/scalatest-propspec_2.13/3.2.17/scalatest-propspec_2.13-3.2.17.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scalatest/scalatest-refspec_2.13/3.2.17/scalatest-refspec_2.13-3.2.17.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scalatest/scalatest-wordspec_2.13/3.2.17/scalatest-wordspec_2.13-3.2.17.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scalatest/scalatest-diagrams_2.13/3.2.17/scalatest-diagrams_2.13-3.2.17.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scalatest/scalatest-matchers-core_2.13/3.2.17/scalatest-matchers-core_2.13-3.2.17.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scalatest/scalatest-shouldmatchers_2.13/3.2.17/scalatest-shouldmatchers_2.13-3.2.17.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scalatest/scalatest-mustmatchers_2.13/3.2.17/scalatest-mustmatchers_2.13-3.2.17.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-reflect/2.13.12/scala-reflect-2.13.12.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/io/github/classgraph/classgraph/4.8.78/classgraph-4.8.78.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/modules/scala-collection-compat_2.13/2.1.1/scala-collection-compat_2.13-2.1.1.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/apache/commons/commons-math3/3.2/commons-math3-3.2.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/apache/commons/commons-lang3/3.4/commons-lang3-3.4.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/modules/scala-xml_2.13/2.1.0/scala-xml_2.13-2.1.0.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/modules/scala-parser-combinators_2.13/1.1.2/scala-parser-combinators_2.13-1.1.2.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/ow2/asm/asm/5.0.4/asm-5.0.4.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/jline/jline/3.10.0/jline-3.10.0.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scalameta/junit-interface/0.7.26/junit-interface-0.7.26.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/junit/junit/4.13.2/junit-4.13.2.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scalatest/scalatest-compatible/3.2.17/scalatest-compatible-3.2.17.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scalactic/scalactic_2.13/3.2.17/scalactic_2.13-3.2.17.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-sbt/test-interface/1.0/test-interface-1.0.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scalameta/mdoc-runtime_2.13/2.5.2/mdoc-runtime_2.13-2.5.2.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/com/lihaoyi/fansi_2.13/0.4.0/fansi_2.13-0.4.0.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/com/lihaoyi/pprint_2.13/0.8.1/pprint_2.13-0.8.1.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scalameta/mdoc-interfaces/2.5.2/mdoc-interfaces-2.5.2.jar [exists ], <HOME>/.cache/coursier/v1/https/repo1.maven.org/maven2/com/geirsson/metaconfig-pprint_2.13/0.12.0/metaconfig-pprint_2.13-0.12.0.jar [exists ]
Options:
-Yrangepos -Xplugin-require:semanticdb


action parameters:
uri: file://<WORKSPACE>/src/test/scala/pruebas.worksheet.sc
text:
```scala
import scala.util.Random
import common._
import Benchmark._
import math._
import scala.collection.parallel.immutable._
import java.io._
type Matriz = Vector[Vector[Int]]
type AlgoritmoMult = (Matriz, Matriz) => Matriz

val random = new Random()

def matrizAlAzar(long: Int, vals: Int): Matriz = {
  val v = Vector.fill(long, long) { random.nextInt(vals) }
  v
}

def vectorAlAzar(long: Int, vals: Int): Vector[Int] = {
  val v = Vector.fill(long) { random.nextInt(vals) }
  v
}

def prodPunto(v1: Vector[Int], v2: Vector[Int]): Int = {
  (v1 zip v2).map({ case (i, j) => (i * j) }).sum
}

def transpuesta(m: Matriz): Matriz = {
  val l = m.length
  Vector.tabulate(l, l)((i, j) => m(j)(i))
}

def multMatriz(m1: Matriz, m2: Matriz): Matriz = {
  val l = m1.length
  val T = transpuesta(m2)
  Vector.tabulate(l, l)((i, j) => prodPunto(m1(i), T(j)))
}

def multMatrizPar(m1: Matriz, m2: Matriz): Matriz = {
  val l = m1.length
  val T = transpuesta(m2)
  Vector.tabulate(l, l)((i, j) => task(prodPunto(m1(i), T(j)))) map (v =>
    v map (_.join)
  )
}

def subMatriz(m: Matriz, i: Int, j: Int, l: Int): Matriz =
  Vector.tabulate(l, l)((z, r) => m(z + i)(r + j))

def sumMatriz(m1: Matriz, m2: Matriz): Matriz =
  Vector.tabulate(m1.length, m1.length)((i, j) => m1(i)(j) + m2(i)(j))

def crearMatrizC(
    c11: Matriz,
    c12: Matriz,
    c21: Matriz,
    c22: Matriz,
    l: Int
): Matriz = {
  val mitad = l / 2
  Vector.tabulate(l, l)((i, j) =>
    if (i < mitad && j < mitad) c11(i)(j)
    else if (i < mitad) c12(i)(j - mitad)
    else if (j < mitad) c21(i - mitad)(j)
    else c22(i - mitad)(j - mitad)
  )
}

def multMatrizRec(m1: Matriz, m2: Matriz): Matriz = {

  if (m1.length == 1) {
    Vector(Vector(m1(0)(0) * m2(0)(0))): Matriz
  } else {

    val l = m1.length
    val mitad = l / 2
    val A11 = subMatriz(m1, 0, 0, mitad)
    val A12 = subMatriz(m1, 0, mitad, mitad)
    val A21 = subMatriz(m1, mitad, 0, mitad)
    val A22 = subMatriz(m1, mitad, mitad, mitad)
    val B11 = subMatriz(m2, 0, 0, mitad)
    val B12 = subMatriz(m2, 0, mitad, mitad)
    val B21 = subMatriz(m2, mitad, 0, mitad)
    val B22 = subMatriz(m2, mitad, mitad, mitad)
    val C11 = sumMatriz(multMatrizRec(A11, B11), multMatrizRec(A12, B21))
    val C12 = sumMatriz(multMatrizRec(A11, B12), multMatrizRec(A12, B22))
    val C21 = sumMatriz(multMatrizRec(A21, B11), multMatrizRec(A22, B21))
    val C22 = sumMatriz(multMatrizRec(A21, B12), multMatrizRec(A22, B22))

    crearMatrizC(C11, C12, C21, C22, l)
  }
}

/*def multMatrizRecPar(m1: Matriz, m2: Matriz): Matriz = {
  val l = m1.length
  if (l == 1) {
    Vector(Vector(m1(0)(0) * m2(0)(0))): Matriz
  } else {
    val mitad = l / 2
    val A11 = subMatriz(m1, 0, 0, mitad)
    val A12 = subMatriz(m1, 0, mitad, mitad)
    val A21 = subMatriz(m1, mitad, 0, mitad)
    val A22 = subMatriz(m1, mitad, mitad, mitad)
    val B11 = subMatriz(m2, 0, 0, mitad)
    val B12 = subMatriz(m2, 0, mitad, mitad)
    val B21 = subMatriz(m2, mitad, 0, mitad)
    val B22 = subMatriz(m2, mitad, mitad, mitad)
    val (c11, c12, c21, c22) = parallel(
      sumMatriz(multMatrizRec(A11, B11), multMatrizRec(A12, B21)),
      sumMatriz(multMatrizRec(A11, B12), multMatrizRec(A12, B22)),
      sumMatriz(multMatrizRec(A21, B11), multMatrizRec(A22, B21)),
      sumMatriz(multMatrizRec(A21, B12), multMatrizRec(A22, B22))
    )

    Vector.tabulate(l, l)((i, j) =>
      if (i < mitad && j < mitad) c11(i)(j)
      else if (i < mitad) c12(i)(j - mitad)
      else if (j < mitad) c21(i - mitad)(j)
      else c22(i - mitad)(j - mitad)
    )
  }
}*/

/*def multMatrizRecPar(m1: Matriz, m2: Matriz): Matriz = {
  val umbral = pow(2, 3)
  val l = m1.length
  if (l == 1) {
    Vector(Vector(m1(0)(0) * m2(0)(0))): Matriz
  } else {

    val mitad = l / 2
    val A11 = subMatriz(m1, 0, 0, mitad)
    val A12 = subMatriz(m1, 0, mitad, mitad)
    val A21 = subMatriz(m1, mitad, 0, mitad)
    val A22 = subMatriz(m1, mitad, mitad, mitad)
    val B11 = subMatriz(m2, 0, 0, mitad)
    val B12 = subMatriz(m2, 0, mitad, mitad)
    val B21 = subMatriz(m2, mitad, 0, mitad)
    val B22 = subMatriz(m2, mitad, mitad, mitad)
    if (l <= umbral) {
      val c11 =
        sumMatriz(multMatrizRecPar(A11, B11), multMatrizRecPar(A12, B21))
      val c12 =
        sumMatriz(multMatrizRecPar(A11, B12), multMatrizRecPar(A12, B22))
      val c21 =
        sumMatriz(multMatrizRecPar(A21, B11), multMatrizRecPar(A22, B21))
      val c22 =
        sumMatriz(multMatrizRecPar(A21, B12), multMatrizRecPar(A22, B22))
      crearMatrizC(c11, c12, c21, c22, l)
    } else {
      val (c11, c12, c21, c22) = parallel(
        sumMatriz(multMatrizRecPar(A11, B11), multMatrizRecPar(A12, B21)),
        sumMatriz(multMatrizRecPar(A11, B12), multMatrizRecPar(A12, B22)),
        sumMatriz(multMatrizRecPar(A21, B11), multMatrizRecPar(A22, B21)),
        sumMatriz(multMatrizRecPar(A21, B12), multMatrizRecPar(A22, B22))
      )
      crearMatrizC(c11, c12, c21, c22, l)
    }
  }
}
 */

/*def multMatrizRecPar2(m1: Matriz, m2: Matriz): Matriz = {
  val umbral = pow(2, 3)
  val l = m1.length
  if (l == 1) {
    Vector(Vector(m1(0)(0) * m2(0)(0))): Matriz
  } else {

    val mitad = l / 2
    val A11 = subMatriz(m1, 0, 0, mitad)
    val A12 = subMatriz(m1, 0, mitad, mitad)
    val A21 = subMatriz(m1, mitad, 0, mitad)
    val A22 = subMatriz(m1, mitad, mitad, mitad)
    val B11 = subMatriz(m2, 0, 0, mitad)
    val B12 = subMatriz(m2, 0, mitad, mitad)
    val B21 = subMatriz(m2, mitad, 0, mitad)
    val B22 = subMatriz(m2, mitad, mitad, mitad)
    if (l <= umbral) {
      val c11 =
        sumMatriz(multMatrizRecPar2(A11, B11), multMatrizRecPar2(A12, B21))
      val c12 =
        sumMatriz(multMatrizRecPar2(A11, B12), multMatrizRecPar2(A12, B22))
      val c21 =
        sumMatriz(multMatrizRecPar2(A21, B11), multMatrizRecPar2(A22, B21))
      val c22 =
        sumMatriz(multMatrizRecPar2(A21, B12), multMatrizRecPar2(A22, B22))
      crearMatrizC(c11, c12, c21, c22, l)
    } else {
      val A11B11 = task(multMatrizRecPar2(A11, B11))
      val A12B21 = task(multMatrizRecPar2(A12, B21))
      val A11B12 = task(multMatrizRecPar2(A11, B12))
      val A12B22 = task(multMatrizRecPar2(A12, B22))
      val A21B11 = task(multMatrizRecPar2(A21, B11))
      val A22B21 = task(multMatrizRecPar2(A22, B21))
      val A21B12 = task(multMatrizRecPar2(A21, B12))
      val A22B22 = task(multMatrizRecPar2(A22, B22))

      val (c11, c12, c21, c22) = parallel (
        sumMatriz(A11B11.join, A12B21.join),
        sumMatriz(A11B12.join, A12B22.join),
        sumMatriz(A21B11.join, A22B21.join),
        sumMatriz(A21B12.join, A22B22.join)
      )
      crearMatrizC(c11, c12, c21, c22, l)
    }
  }
}*/

def restaMatriz(m1: Matriz, m2: Matriz): Matriz = {
  Vector.tabulate(m1.length, m1.length)((i, j) => m1(i)(j) - m2(i)(j))
}

def multStrassen(m1: Matriz, m2: Matriz): Matriz = {
  val l = m1.length
  if (l == 1) {
    Vector(Vector(m1(0)(0) * m2(0)(0))): Matriz
  } else {
    val mitad = l / 2
    val (a11, a12, a21, a22) = (
      subMatriz(m1, 0, 0, mitad),
      subMatriz(m1, 0, mitad, mitad),
      subMatriz(m1, mitad, 0, mitad),
      subMatriz(m1, mitad, mitad, mitad)
    )

    val (b11, b12, b21, b22) = (
      subMatriz(m2, 0, 0, mitad),
      subMatriz(m2, 0, mitad, mitad),
      subMatriz(m2, mitad, 0, mitad),
      subMatriz(m2, mitad, mitad, mitad)
    )

    val P1 = multStrassen(a11, restaMatriz(b12, b22))
    val P2 = multStrassen(sumMatriz(a11, a12), b22)
    val P3 = multStrassen(sumMatriz(a21, a22), b11)
    val P4 = multStrassen(a22, restaMatriz(b21, b11))
    val P5 = multStrassen(sumMatriz(a11, a22), sumMatriz(b11, b22))
    val P6 = multStrassen(restaMatriz(a12, a22), sumMatriz(b21, b22))
    val P7 = multStrassen(restaMatriz(a11, a21), sumMatriz(b11, b12))

    val (c11, c12, c21, c22) = (
      sumMatriz(sumMatriz(P5, P6), restaMatriz(P4, P2)),
      sumMatriz(P1, P2),
      sumMatriz(P3, P4),
      sumMatriz(P5, restaMatriz(restaMatriz(P1, P3), P7))
    )

    crearMatrizC(c11, c12, c21, c22, l)

  }
}

/*def multStrassenPar(m1: Matriz, m2: Matriz): Matriz = {
  val umbral = pow(2, 3)
  val l = m1.length
  if (l == 1) {
    Vector(Vector(m1(0)(0) * m2(0)(0))): Matriz
  } else {
    val mitad = l / 2
    val (a11, a12, a21, a22) = (
      subMatriz(m1, 0, 0, mitad),
      subMatriz(m1, 0, mitad, mitad),
      subMatriz(m1, mitad, 0, mitad),
      subMatriz(m1, mitad, mitad, mitad)
    )

    val (b11, b12, b21, b22) = (
      subMatriz(m2, 0, 0, mitad),
      subMatriz(m2, 0, mitad, mitad),
      subMatriz(m2, mitad, 0, mitad),
      subMatriz(m2, mitad, mitad, mitad)
    )

    if (l <= umbral) {

      val P1 = multStrassenPar(a11, restaMatriz(b12, b22))
      val P2 = multStrassenPar(sumMatriz(a11, a12), b22)
      val P3 = multStrassenPar(sumMatriz(a21, a22), b11)
      val P4 = multStrassenPar(a22, restaMatriz(b21, b11))
      val P5 = multStrassenPar(sumMatriz(a11, a22), sumMatriz(b11, b22))
      val P6 = multStrassenPar(restaMatriz(a12, a22), sumMatriz(b21, b22))
      val P7 = multStrassenPar(restaMatriz(a11, a21), sumMatriz(b11, b12))

      val (c11, c12, c21, c22) = (
        sumMatriz(sumMatriz(P5, P6), restaMatriz(P4, P2)),
        sumMatriz(P1, P2),
        sumMatriz(P3, P4),
        sumMatriz(P5, restaMatriz(restaMatriz(P1, P3), P7))
      )

      crearMatrizC(c11, c12, c21, c22, l)

    } else {

      val P1 = task(multStrassenPar(a11, restaMatriz(b12, b22)))
      val P2 = task(multStrassenPar(sumMatriz(a11, a12), b22))
      val P3 = task(multStrassenPar(sumMatriz(a21, a22), b11))
      val P4 = task(multStrassenPar(a22, restaMatriz(b21, b11)))
      val P5 = task(multStrassenPar(sumMatriz(a11, a22), sumMatriz(b11, b22)))
      val P6 = task(multStrassenPar(restaMatriz(a12, a22), sumMatriz(b21, b22)))
      val P7 = task(multStrassenPar(restaMatriz(a11, a21), sumMatriz(b11, b12)))

      val (c11, c12, c21, c22) = (
        sumMatriz(sumMatriz(P5.join, P6.join), restaMatriz(P4.join, P2.join)),
        sumMatriz(P1.join, P2.join),
        sumMatriz(P3.join, P4.join),
        sumMatriz(P5.join, restaMatriz(restaMatriz(P1.join, P3.join), P7.join))
      )

      crearMatrizC(c11, c12, c21, c22, l)
    }

  }
}
 */

/*def multStrassenPar2(m1: Matriz, m2: Matriz): Matriz = {
  val l = m1.length
  if (l == 1) {
    Vector(Vector(m1(0)(0) * m2(0)(0))): Matriz
  } else {
    val mitad = l / 2
    val (a11, a12, a21, a22) = (
      subMatriz(m1, 0, 0, mitad),
      subMatriz(m1, 0, mitad, mitad),
      subMatriz(m1, mitad, 0, mitad),
      subMatriz(m1, mitad, mitad, mitad)
    )

    val (b11, b12, b21, b22) = (
      subMatriz(m2, 0, 0, mitad),
      subMatriz(m2, 0, mitad, mitad),
      subMatriz(m2, mitad, 0, mitad),
      subMatriz(m2, mitad, mitad, mitad)
    )

    val P1 = multStrassenPar2(a11, restaMatriz(b12, b22))
    val P2 = multStrassenPar2(sumMatriz(a11, a12), b22)
    val P3 = multStrassenPar2(sumMatriz(a21, a22), b11)
    val P4 = multStrassenPar2(a22, restaMatriz(b21, b11))
    val P5 = multStrassenPar2(sumMatriz(a11, a22), sumMatriz(b11, b22))
    val P6 = multStrassenPar2(restaMatriz(a12, a22), sumMatriz(b21, b22))
    val P7 = multStrassenPar2(restaMatriz(a11, a21), sumMatriz(b11, b12))

    val (c11, c12, c21, c22) = parallel(
      sumMatriz(sumMatriz(P5, P6), restaMatriz(P4, P2)),
      sumMatriz(P1, P2),
      sumMatriz(P3, P4),
      sumMatriz(P5, restaMatriz(restaMatriz(P1, P3), P7))
    )

    crearMatrizC(c11, c12, c21, c22, l)

  }
}*/

def prodPuntoParD(v1: ParVector[Int], v2: ParVector[Int]): Int = {
  (v1 zip v2).map({ case (i, j) => (i * j) }).sum
}

//compararAlgoritmos(multMatrizRec, multMatrizRecPar2)(mp1, mp2)

/*val lista =
  for (i <- (1 to 8))
    yield compararAlgoritmos(multMatrizRec, multMatrizRecPar)(mp1, mp2)._3

lista.sum / lista.length*/

//multStrassenPar(mp1,mp2)

//------------------------------------------------------------------------ funciones mejoradas

def multMatrizRecPar(m1: Matriz, m2: Matriz): Matriz = {
  val umbral = pow(2, 3)
  val l = m1.length

  if (l <= umbral) {

    multMatrizRec(m1, m2)

  } else {

    val mitad = l / 2
    val A11 = subMatriz(m1, 0, 0, mitad)
    val A12 = subMatriz(m1, 0, mitad, mitad)
    val A21 = subMatriz(m1, mitad, 0, mitad)
    val A22 = subMatriz(m1, mitad, mitad, mitad)
    val B11 = subMatriz(m2, 0, 0, mitad)
    val B12 = subMatriz(m2, 0, mitad, mitad)
    val B21 = subMatriz(m2, mitad, 0, mitad)
    val B22 = subMatriz(m2, mitad, mitad, mitad)

    val (c11, c12, c21, c22) = parallel(
      sumMatriz(multMatrizRecPar(A11, B11), multMatrizRecPar(A12, B21)),
      sumMatriz(multMatrizRecPar(A11, B12), multMatrizRecPar(A12, B22)),
      sumMatriz(multMatrizRecPar(A21, B11), multMatrizRecPar(A22, B21)),
      sumMatriz(multMatrizRecPar(A21, B12), multMatrizRecPar(A22, B22))
    )
    crearMatrizC(c11, c12, c21, c22, l)
  }

}

def multStrassenPar(m1: Matriz, m2: Matriz): Matriz = {
  val umbral = pow(2, 3)
  val l = m1.length

  if (l <= umbral) {

    multStrassen(m1, m2)

  } else {
    val mitad = l / 2
    val (a11, a12, a21, a22) = (
      subMatriz(m1, 0, 0, mitad),
      subMatriz(m1, 0, mitad, mitad),
      subMatriz(m1, mitad, 0, mitad),
      subMatriz(m1, mitad, mitad, mitad)
    )

    val (b11, b12, b21, b22) = (
      subMatriz(m2, 0, 0, mitad),
      subMatriz(m2, 0, mitad, mitad),
      subMatriz(m2, mitad, 0, mitad),
      subMatriz(m2, mitad, mitad, mitad)
    )
    val P1 = task(multStrassenPar(a11, restaMatriz(b12, b22)))
    val P2 = task(multStrassenPar(sumMatriz(a11, a12), b22))
    val P3 = task(multStrassenPar(sumMatriz(a21, a22), b11))
    val P4 = task(multStrassenPar(a22, restaMatriz(b21, b11)))
    val P5 = task(multStrassenPar(sumMatriz(a11, a22), sumMatriz(b11, b22)))
    val P6 = task(multStrassenPar(restaMatriz(a12, a22), sumMatriz(b21, b22)))
    val P7 = task(multStrassenPar(restaMatriz(a11, a21), sumMatriz(b11, b12)))

    val (c11, c12, c21, c22) = (
      sumMatriz(sumMatriz(P5.join, P6.join), restaMatriz(P4.join, P2.join)),
      sumMatriz(P1.join, P2.join),
      sumMatriz(P3.join, P4.join),
      sumMatriz(P5.join, restaMatriz(restaMatriz(P1.join, P3.join), P7.join))
    )

    crearMatrizC(c11, c12, c21, c22, l)

  }

}

//-----------------Pruebas-----------------------------------------------

//val mp1 = matrizAlAzar(pow(2, 1).toInt, 2)
//val mp2 = matrizAlAzar(pow(2, 1).toInt, 2)

/*val l = for {
  n <- 1 to 2
  mp1 = matrizAlAzar(pow(2, n).toInt, 2)
  mp2 = matrizAlAzar(pow(2, n).toInt, 2)
  algoritmos = List(
    compararAlgoritmos(multMatriz, multMatrizPar)(mp1, mp2),
    compararAlgoritmos(multMatrizRec, multMatrizRecPar)(mp1, mp2),
    compararAlgoritmos(multStrassen, multStrassenPar)(mp1, mp2)
  )

} yield for {
  alg <- algoritmos

} yield for {
  rep <- 1 to 5
} yield alg



// Definir la ruta del archivo CSV
val csvFilePath = "output.csv"

// Crear un PrintWriter para escribir en el archivo CSV
val writer = new PrintWriter(new File(csvFilePath))

// Iterar sobre cada nivel de la estructura y escribir los datos en el archivo CSV
l.foreach { outerList =>
  outerList.foreach { innerVector =>
    innerVector.foreach { case (a, b, c) =>
      writer.println(s"$a,$b,$c")
    }
  }
}

// Cerrar el PrintWriter
writer.close()
 */
/*val comparaciones=List[(AlgoritmoMult,AlgoritmoMult)]((multMatriz,multMatrizPar),(multMatrizRec,multMatrizRecPar),(multStrassen,multStrassenPar))

def crearPruevas(
    tamañoMatriz: Int,
    numPruebas: Int,
    comparaciones:List[(AlgoritmoMult,AlgoritmoMult)]
): IndexedSeq[List[IndexedSeq[(Double, Double, Double)]]] = {

  for {
    n <- 1 to tamañoMatriz
    mp1 = matrizAlAzar(pow(2, n).toInt, 2)
    mp2 = matrizAlAzar(pow(2, n).toInt, 2)

  } yield for {
    comparacion<-comparaciones
  } yield for {
    rep <- 1 to numPruebas
  } yield compararAlgoritmos(comparacion._1,comparacion._2)(mp1,mp2)

}*/

def crearPruevas(
    tamañoMatriz: Range,
    numPruebas: Int,
    algoritmos: (AlgoritmoMult, AlgoritmoMult)
): IndexedSeq[IndexedSeq[((Double, Double, Double), Double)]] = {

  for {
    n <- tamañoMatriz
    mp1 = matrizAlAzar(pow(2, n).toInt, 2)
    mp2 = matrizAlAzar(pow(2, n).toInt, 2)

  } yield for {
    rep <- 1 to numPruebas
  } yield (
    compararAlgoritmos(algoritmos._1, algoritmos._2)(mp1, mp2),
    pow(2, n)
  )

}

def escrivirCsv(
    rutacsv: String,
    datos: IndexedSeq[IndexedSeq[((Double, Double, Double), Double)]]
): Unit = {

  val csvFilePath = rutacsv

  val writer = new PrintWriter(new File(csvFilePath))

  datos.foreach { outerList =>
    outerList.foreach { case ((a, b, c), d) =>
      writer.println(s"$d,$a,$b,$c")
    }

  }
  writer.close()
}

def crearPruevasProdP(rangoPruebas: Range, rangoTamañoVector: Range) = {
  for {
    tamaño <- rangoTamañoVector
  } yield for {
    prueva <- rangoPruebas
  } yield (compararProdPunto(tamaño),tamaño)
}

crearPruevasProdP(1 to 5,10 to 1000 by 10)
def escrivirCsvProdP(rutaCsv:String,datos:IndexedSeq[IndexedSeq[((Double, Double, Double), Int)]])={
  datos.foreach(outerVector=>outerVector.foreach{
    case(((a,b,c),d))=> writer.println(s"d,$")
  })

}

//-------------------------------------------------PRUEBAS MULTIPLICACION---------------------------------------------------------------------------------------------------------

//---pruevas para multMatriz-multMatrizPar
//escrivirCsv("multMatriz-multMatrizPar.CSV", crearPruevas(1 to 10, 5, (multMatriz, multMatrizPar)))

//---pruevas para multMatrizRec-multMatrizRecPar
//escrivirCsv("multMatrizRec-multMatrizRecPar.CSV", crearPruevas(1 to 10, 5, (multMatrizRec, multMatrizRecPar)))

//---pruevas para multStrassen-multStrassenPar
//escrivirCsv("multStrassen-multStrassenPar.CSV", crearPruevas(1 to 10, 5, (multStrassen, multStrassenPar)))

//---pruevas para multMatriz-multMatrizRec
//escrivirCsv("multMatrizRec-multMatriz.CSV", crearPruevas(1 to 10, 5, ( multMatrizRec,multMatriz)))

//---pruevas para multMatriz-multStrassen
//escrivirCsv("multStrassen-multMatriz.CSV", crearPruevas(1 to 10, 5, ( multStrassen,multMatriz))

//---pruevas para multMatrizRec-multStrassen
//escrivirCsv("multMatrizRec-multStrassen.CSV", crearPruevas(1 to 10, 5, (multMatrizRec, multStrassen)))

//---pruevas para multMatrizRecPar-multMatrizPar
//escrivirCsv("multMatrizRecPar-multMatrizPar.CSV", crearPruevas(1 to 10, 5, ( multMatrizRecPar,multMatrizPar)))

//---pruevas para multStrassenPar-multMatrizPar
//escrivirCsv("multStrassenPar-multMatrizPar.CSV", crearPruevas(1 to 10, 5, (multStrassenPar, multMatrizPar)))

//---pruevas para multMatrizRecPar-multStrassenPar
//escrivirCsv("multMatrizRecPar-multStrassenPar.CSV", crearPruevas(1 to 10, 5, (multMatrizRecPar, multStrassenPar)))

```



#### Error stacktrace:

```
scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:656)
	scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:364)
	scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:383)
	scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	scala.meta.internal.parsers.ScannerTokens$.apply(ScannerTokens.scala:994)
	scala.meta.internal.parsers.ScalametaParser.<init>(ScalametaParser.scala:33)
	scala.meta.parsers.Parse$$anon$1.apply(Parse.scala:35)
	scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:206)
	scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:54)
	scala.meta.internal.pc.ScalaPresentationCompiler.$anonfun$semanticdbTextDocument$1(ScalaPresentationCompiler.scala:400)
```
#### Short summary: 

file%3A%2F%2F%2Fhome%2Fandresuv%2FcuartoSemestre%2FPFC%2Fentregables%2Fmatrices%2Fsrc%2Ftest%2Fscala%2Fpruebas.worksheet.sc:559: error: Not one of: `$$', `$'ident, `$'this, `$'BlockExpr, `$'_
    case(((a,b,c),d))=> writer.println(s"d,$")
                                         ^